[{"content":"静态提升 静态节点提升 编译器将模板编译成render函数的时候，会发现静态节点，然后进行静态提升。\n静态提升是以树为单位\n例如：\n\u0026lt;div\u0026gt; \u0026lt;div\u0026gt;foo\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{{ bar }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 对应的渲染函数：\n// before function render() { return ( openBlock(), createBlock(\u0026#39;div\u0026#39;, null, [ createVNode(\u0026#39;p\u0026#39;, null, \u0026#39;foo\u0026#39;), createVNode(\u0026#39;p\u0026#39;, null, ctx.bar, 1 /*TEXT*/), ]) ) } // after // 将纯静态的 虚拟节点提升 const hosit1 = createVNode(\u0026#39;p\u0026#39;, null, \u0026#39;foo\u0026#39;) function render() { return ( openBlock(), createBlock(\u0026#39;div\u0026#39;, null, [ hosit1, // 传递引用，这样每次render时候不会重新生成 createVNode(\u0026#39;p\u0026#39;, null, ctx.bar, 1 /*TEXT*/), ]) ) } 静态属性提升 例如：\n\u0026lt;div\u0026gt; \u0026lt;div foo=\u0026#34;bar\u0026#34; a=b\u0026gt;{{ text }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 可以将静态属性提升\nconst hositProps = { foo: \u0026#39;bar\u0026#39;, a: \u0026#39;b\u0026#39; } function render() { return ( openBlock(), createBlock(\u0026#39;div\u0026#39;, null, [ createVNode(\u0026#39;div\u0026#39;, hositProps, ctx.text, 1 /*TEXT*/), ]) ) } 预字符串化 例如：\n\u0026lt;div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!-- ... 20个p标签 --\u0026gt; \u0026lt;/div\u0026gt; 我们将静态节点序列化为字符串，并生成一个 static 类型的 vnode:\nconst hoistStatic = createStaticVNode(\u0026#39;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;...20个...\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026#39;) render() { return (openBlock(), createBlock(\u0026#39;div\u0026#39;, null, [hoistStatic])) } 优势在于：\n大块的静态内容可以通过 innerHTML 进行设置，性能上有一定优势 减少内容占用 减少虚拟节点 虚拟节点创建产生的性能开销 缓存内联事件处理函数 例如：\n\u0026lt;Comp @change=\u0026#34;a + b\u0026#34;/\u0026gt; 编译器会将其编译为：\nfunction render() { return h(Comp, { onChange: () =\u0026gt; (ctx.a + ctx.b) // 每次重新渲染，都会为组件创建一个全新的 props对象。同时props中的onChange属性值也会是一个 // 全新的值 }) } // 我们增加缓存进行优化 function render() { return h(Comp, { onChange: cache[0] || (cache[0] = ($event) =\u0026gt; (ctx.a + ctx.b)) // 全新的值 }) } PatchFlag \u0026amp; block 靶向更新和block树\n例如模板：\n\u0026lt;div\u0026gt; \u0026lt;div\u0026gt;foo\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{{ bar }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 编译成传统的虚拟dom：\nconst vnode = { tag: \u0026#39;div\u0026#39;, children: [ { tag: \u0026#39;p\u0026#39;, children: \u0026#39;foo\u0026#39;}, { tag: \u0026#39;p\u0026#39;, children: ctx.bar }, ] } 编译优化后，编译器会将提取到他的关键信息附着在vnode上：\n// 只要存在 `patchFlag` 我们称为动态节点。 const PatchFlags = { TEXT: 1, // 表示动态文本内容 CLASS: 2, // 表示动态的 class STYLE: 3, // 表示动态的 style PROPS: 4 // 表示动态的 props // 省略... } const vnode = { tag: \u0026#39;div\u0026#39;, children: [ { tag: \u0026#39;p\u0026#39;, children: \u0026#39;foo\u0026#39;}, { tag: \u0026#39;p\u0026#39;, children: ctx.bar, patchFlag: PatchFlags.TEXT }, // 这是一个动态节点 ] } 有了这项信息，我们可以将动态子节点提出来，存储到该虚拟节点的 dynamicChildren:\nconst vnode = { tag: \u0026#39;div\u0026#39;, children: [ { tag: \u0026#39;p\u0026#39;, children: \u0026#39;foo\u0026#39;}, { tag: \u0026#39;p\u0026#39;, children: ctx.bar, patchFlag: PatchFlags.TEXT }, // 这是一个动态节点 ], // children 中的动态节点被提取到这里 dynamicChildren: [ { tag: \u0026#39;p\u0026#39;, children: ctx.bar, patchFlag: PatchFlags.TEXT }, // 这是一个动态节点 ] } 我们将带有 dynamicChildren 的虚拟节点称为 block（块）\n有了 block 概念后，渲染器更新操作将会以 block 为维度，也就是说，当渲染器在更新一个 block 时，会忽略虚拟节点的 children，而是 直接找到 dynamicChildren 数组，并且只更新数组中的动态节点，从而跳过静态内容，只更新动态内容。同时，由于动态节点中存在补丁标志(PatchFlags), 所以只需要靶向更新。\n什么节点会称为 block 节点？\n所有模板的根节点 带有 v-if、v-for、v-else-if ","permalink":"https://dummyEkko.github.io/posts/tech/vue3%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/","summary":"静态提升 静态节点提升 编译器将模板编译成render函数的时候，会发现静态节点，然后进行静态提升。 静态提升是以树为单位 例如： \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;foo\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{{ bar }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 对应的渲染函数： // before function render() { return ( openBlock(), createBlock(\u0026#39;div\u0026#39;, null, [ createVNode(\u0026#39;p\u0026#39;, null, \u0026#39;foo\u0026#39;), createVNode(\u0026#39;p\u0026#39;, null, ctx.bar, 1 /*TEXT*/), ]) ) } // after // 将纯静态的 虚拟节点提升 const hosit1 = createVNode(\u0026#39;p\u0026#39;, null, \u0026#39;foo\u0026#39;) function render() { return ( openBlock(), createBlock(\u0026#39;div\u0026#39;, null, [ hosit1, // 传递引用，这样每次ren","title":"Vue3编译优化"},{"content":"字体加载 @font-face @font-face 用来申明网络字体，它至少要声明将用于引用字体的名称，并指明相应字体文件的位置。\n@font-face { font-family: \u0026#34;Open Sans\u0026#34;; src: url(\u0026#34;/fonts/OpenSans-Regular-webfont.woff2\u0026#34;) format(\u0026#34;woff2\u0026#34;); } h1 { /* 这个时候才会去下载 font-face 声明的字体 */ font-family: \u0026#34;Open Sans\u0026#34; } @font-face 声明本身不会触发字体下载, 只有通过在网页上使用的样式引用某个字体时，系统才会下载该字体\nunicode-range 使用介绍：\ntodo\n字体渲染 当面临尚未加载的网络字体时，浏览器将面临一个困境：是否应该在网络字体到达之前暂停渲染文本？还是应该在网页字体到达之前以后备字体呈现文本？\n默认情况下，如果关联的网页字体尚未加载，基于 Chromium 和 Firefox 的浏览器将会阻止文本呈现，最长可持续3秒钟; Safari 将无限期地阻止文本呈现。\n概括就是文本不可见在字体还没加载前\n可以使用 font-display 属性来配置此行为。\nfont-display font-display 属性决定了一个 @font-face 在不同的下载时间和可用时间下是如何展示的.\nfont-display 可选值：\n值 屏蔽期 交换期 auto 因浏览器而异 因浏览器而异 block 2-3 秒 无限 swap 0 毫秒 无限 fallback 100 毫秒 3 秒 optional 100 毫秒 无 屏蔽期：屏蔽期从浏览器请求网页字体时开始计算。在屏蔽期间，如果网页字体不可用，相应字体将以不可见的后备字体呈现，因此用户将看不到相应文本。如果在屏蔽期结束后该字体不可用，它将以后备字体呈现。 交换期：交换期在屏蔽期之后。如果网页字体在交换期内可用，则会被“交换”。 如何设置合理的 font-display 如果性能是我们的头等大事 那么使用 font-display: optional。\n优点: 文本渲染的延迟不超过 100 毫秒, 并且能够保证不会发生与字体交换相关的布局偏移(优化CLS)\n缺点: 如果网页字体延迟显示，将无法使用网页字体。\n快速显示文本是首要任务，仍想确保使用网页字体 使用 font-display: swap\n优点: 先会以默认字体展示，等网页字体加载完成后，进行交换。\n缺点：会导致布局偏移。\n总结: 尽早加载字体，例如 link preload 进行预加载。\n确保文本以网页字体显示是首要任务 使用 font-display: block。\n缺点：字体没加载完文本将不可见。\n总结: 尽早加载字体，例如 link preload 进行预加载。\n对字体优化总结 字体加载时机 通过上面文章可以知道 只有读到网络字体被使用时，才会触发@font-face下载逻辑。\n优化方案：\n关键字体通过 preload 进行加载。 前提条件：如果明确字体的情况下。 注意点：字体文件必须通过 CORS 连接，预加载情况下，preload 会忽略 unicode-range 声明，如果使用得当，应仅用于加载一种字体格式。 预先连接到关键的第三方源 link rel=\u0026quot;preconnect\u0026quot; 前提条件：可能多个字体，不明确哪个是关键， 注意点：字体文件必须通过 CORS 连接 字体加载速度 字体加载速度主要是网络优化，一个是字体大小一个是合理的网络传输\n采用 CDN 托管字体和 HTTP/2。 使用 WOFF2 （广泛的浏览器支持，并提供最佳的压缩效果， WOFF2 使用 Brotli，因此其压缩效果比 WOFF 高 30%） 子集 通过使用 unicode-range 会告知浏览器某种字体可用于哪些字符, 将一个大的字体分成几个子集，需要时加载子集从而减小体积 补充 为什么 字体的预加载需要通过 CORS 连接？ todo\n","permalink":"https://dummyEkko.github.io/posts/tech/%E5%AD%97%E4%BD%93%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","summary":"字体加载 @font-face @font-face 用来申明网络字体，它至少要声明将用于引用字体的名称，并指明相应字体文件的位置。 @font-face { font-family: \u0026#34;Open Sans\u0026#34;; src: url(\u0026#34;/fonts/OpenSans-Regular-webfont.woff2\u0026#34;) format(\u0026#34;woff2\u0026#34;); } h1 { /* 这个时候才会去下载 font-face 声明的字体 */ font-family: \u0026#34;Open Sans\u0026#34; } @font-face 声明本身不会触发字体下载, 只有通过在网页上使用的样式引用某个字体时，系统才会下载该字体 unicode-range 使用介绍： todo 字体渲染 当面临尚未加载的","title":"字体最佳实践"},{"content":" Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群 787018782\n","permalink":"https://dummyEkko.github.io/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内 👉Hugo博客交流群 787018782","title":"🤝友链"},{"content":"","permalink":"https://dummyEkko.github.io/about/","summary":"","title":"🙋🏻‍♂️关于"}]
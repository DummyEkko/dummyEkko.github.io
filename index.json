[{"content":"渲染流程 参考文章\n渲染进程 渲染程序进程负责标签页内发生的一切。 合成器和光栅线程也会在渲染程序进程内运行，以便高效、流畅地渲染页面。 渲染程序进程的核心任务是将 HTML、CSS 和 JavaScript 转换为用户可与之互动的网页。\n渲染进程中的主线程会处理大多数工作，例如：\n解析文本字符串 (HTML)，生成 DOM。 计算样式 布局 处理图层 每秒把⻚⾯画 60 次 执⾏全局 JS 代码 执⾏事件处理函数 执⾏计时器的回调函数 Web Worker 或 Service Worker，则部分 JavaScript 将由工作器线程处理。\n渲染流程 DOM构建 为什么需要构建 DOM 树？ 因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。\n预加载资源 网站通常使用图片、CSS 和 JavaScript 等外部资源。\n加快速度，系统会并发运行**“预加载扫描程序”**。如果 HTML 文档中包含 \u0026lt;img\u0026gt; 或 \u0026lt;link\u0026gt; 等内容，预加载扫描器会查看由 HTML 解析器生成的 token，并将请求发送到浏览器进程中的网络线程。\njs是如何阻止dom树构建 当HTML解析器找到 \u0026lt;script\u0026gt; 标记时，它会暂停解析 HTML 文档，并加载、解析并执行 JavaScript 代码。因为 js 可能会修改当前已经生成的dom结构。\n不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行。\n样式计算（Recalculate Style） 样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成:\n把 CSS 转换为浏览器能够理解的结构——styleSheets。 转换样式表中的属性值，使其标准化(主要是将指标准化)。 计算出 DOM 树中每个节点的具体样式(遵守 CSS 的继承和层叠两个规则) 布局 布局是查找元素几何形状的过程。主线程会遍历 DOM 和计算出的样式，并创建包含 x y 坐标和边界框大小等信息的布局树。\n布局树的结构可能与 DOM 树类似，但它仅包含与页面上可见内容相关的信息。 display: none，则该元素不属于布局树的一部分（但是，具有 visibility: hidden 的元素位于布局树中）。\n分层 渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）\n那么需要满足什么条件，渲染引擎才会为特定的节点创建新的图层呢？\n拥有层叠上下文属性的元素会被提升为单独的一层（position, z-index, filter: blur(5px), opacity 需要剪裁（clip）的地方也会被创建为图层 主线程会将该信息提交到合成器线程。\n图层绘制 合成器线程会把一个图层的绘制拆分成很多图块，并将每个图块发送到光栅线程。\n光栅化 光栅线程会光栅化每个图块并将其存储在 GPU 内存中。\n合成和显示 将图块进行光栅化后，合成器线程会收集称为“绘制四边形”的图块信息，以创建合成器帧。然后通过 IPC 将合成器帧提交到浏览器进程。\n合成的优势在于，它在完成时不涉及主线程。合成器线程不需要等待样式计算或 JavaScript 执行。因此，仅合成动画被认为是实现流畅性能的最佳方式。如果需要再次计算布局或绘制，则必须涉及主线程。\n总结 渲染进程将 HTML 生成 DOM树结构 将 CSS 样式表 转换成 styleSheets 创建布局树，并且计算布局信息（位置，是否显示）。 分层，生成图层树，提交给合成线程。 合成线程将图层分为多个图块，发给光栅线程。 光栅线程光栅化每个图块并存于GPU中 合成线程创建合成器帧 通过IPC提交给浏览器进程，界面更改，这些合成器帧会发送到 GPU 以在屏幕上显示。 ","permalink":"https://dummyEkko.github.io/posts/tech/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/","summary":"渲染流程 参考文章 渲染进程 渲染程序进程负责标签页内发生的一切。 合成器和光栅线程也会在渲染程序进程内运行，以便高效、流畅地渲染页面。 渲染程序进程的核心任务是将 HTML、CSS 和 JavaScript 转换为用户可与之互动的网页。 渲染进程中的主线程会处理大多数工作，例如： 解析文本字符串 (HTML)，生成 DO","title":"渲染流程"},{"content":"懒加载 懒加载也叫延迟加载，延迟加载这一解决方案可以减少初始网页载荷和加载时间。\n我们通常会延迟加载 非关键资源，在需要的时候再加载这些非关键资源。就图片来说，“非关键”通常指的是“屏幕外”。\n为何要延迟加载图片或视频？ 减少初始网页加载时间、初始页面重量以及系统资源用量。 用户可能永远不查看该内容，这样避免浪费流量，费处理时间、电量和其他资源（下载媒体资源后，浏览器必须对其进行解码，并在视口中呈现其内容）。 效果如：\n延迟加载图片 loading 属性 Chrome 和 Firefox 都支持通过 loading 属性进行延迟加载。\n可选值：\neager: 立即加载图像，不管它是否在可视视口（visible viewport）之外（默认值） lazy: 延迟加载图像，直到它和视口接近到一个计算得到的距离（由浏览器定义）。目的是在需要图像之前，避免加载图像所需要的网络和存储带宽。 如果浏览器不支持延迟加载，系统会忽略该属性，并照常立即加载图片。\n判断是否支持 loading\nif (\u0026#39;loading\u0026#39; in HTMLImageElement.prototype) { // supported in browser } else { // fetch polyfill/third-party library } scroll 或 resize \u0026lt;body\u0026gt; \u0026lt;img loading=\u0026#34;lazy\u0026#34; class=\u0026#39;img-item\u0026#39; src=\u0026#34;https://img.zcool.cn/community/011e0e5c231dcaa80121df9063b03f.jpg@1280w_1l_2o_100sh.jpg\u0026#34; data-original=\u0026#34;https://img.zcool.cn/community/011e0e5c231dcaa80121df9063b03f.jpg@1280w_1l_2o_100sh.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;img loading=\u0026#34;lazy\u0026#34; class=\u0026#39;img-item\u0026#39; src=\u0026#34;\u0026#34; data-original=\u0026#34;https://img.zcool.cn/community/01427a5c63c7dba801213f26fa8f1f.jpg@1280w_1l_2o_100sh.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;img loading=\u0026#34;lazy\u0026#34; class=\u0026#39;img-item\u0026#39; src=\u0026#34;\u0026#34; data-original=\u0026#34;https://img.zcool.cn/community/0132fb60a7171011013f472074ee82.jpg@1280w_1l_2o_100sh.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;img loading=\u0026#34;lazy\u0026#34; class=\u0026#39;img-item\u0026#39; src=\u0026#34;\u0026#34; data-original=\u0026#34;https://pic2.zhimg.com/v2-ac79ec66a08cdbbfd36c3f9e4f307077_1440w.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;img loading=\u0026#34;lazy\u0026#34; class=\u0026#39;img-item\u0026#39; src=\u0026#34;\u0026#34; data-original=\u0026#34;https://img.zcool.cn/community/01702360a7171511013e3b7d2249ef.jpg@1280w_1l_2o_100sh.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;img loading=\u0026#34;lazy\u0026#34; class=\u0026#39;img-item\u0026#39; src=\u0026#34;\u0026#34; data-original=\u0026#34;https://img.zcool.cn/community/01c9e05da91bcea8012163bae9a7ea.jpg@2o.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;img loading=\u0026#34;lazy\u0026#34; class=\u0026#39;img-item\u0026#39; src=\u0026#34;\u0026#34; data-original=\u0026#34;https://img.zcool.cn/community/010c155dcec2b0a8012053c0802a12.jpg@3000w_1l_0o_100sh.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;img loading=\u0026#34;lazy\u0026#34; class=\u0026#39;img-item\u0026#39; src=\u0026#34;\u0026#34; data-original=\u0026#34;https://pic2.zhimg.com/v2-b2ab50d677e6f8a9101dae446dd99acd_r.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;img loading=\u0026#34;lazy\u0026#34; class=\u0026#39;img-item\u0026#39; src=\u0026#34;\u0026#34; data-original=\u0026#34;https://img.3dmgame.com/uploads/images/thumbpicfirst/20180824/1535099402_352803.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;img loading=\u0026#34;lazy\u0026#34; class=\u0026#39;img-item\u0026#39; src=\u0026#34;\u0026#34; data-original=\u0026#34;https://img.zcool.cn/community/0193a55b9df41ba8012099c8aedcd0.jpg@3000w_1l_0o_100sh.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;script\u0026gt; // 拿到可视觉区域的高度 let viewHeight = document.documentElement.clientHeight; function lazyLoad(){ // 拿到所有的img元素 let imgs = document.querySelectorAll(\u0026#39;img[data-original]\u0026#39;); imgs.forEach(el=\u0026gt;{ // getBoundingClientRect()专门获取容器的几何信息 let rect = el.getBoundingClientRect() if(rect.top \u0026lt; viewHeight){ // img元素自带一个构造函数，可以创建一个图片对象 let image = new Image() // js专有写法dataset.original; = data-original image.src = el.dataset.original; image.onload = function(){ el.src = image.src } // 图片加载完毕就移除属性 el.removeAttribute(\u0026#39;data-original\u0026#39;) } }) } lazyLoad() // 添加滚动事件监听器 document.addEventListener(\u0026#39;scroll\u0026#39;,lazyLoad) \u0026lt;/script\u0026gt; Intersection Observer 性能更佳且更高效\n\u0026lt;script\u0026gt; document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() { var lazyImages = [].slice.call(document.querySelectorAll(\u0026#34;img.img-item\u0026#34;)); if (\u0026#34;IntersectionObserver\u0026#34; in window) { let lazyImageObserver = new IntersectionObserver(function(entries, observer) { entries.forEach(function(entry) { if (entry.isIntersecting) { let lazyImage = entry.target; lazyImage.src = lazyImage.dataset.original; // lazyImage.srcset = lazyImage.dataset.srcset; // lazyImage.classList.remove(\u0026#34;lazy\u0026#34;); lazyImageObserver.unobserve(lazyImage); } }); }); lazyImages.forEach(function(lazyImage) { lazyImageObserver.observe(lazyImage); }); } else { } \u0026lt;/script\u0026gt; 总结 可以通过 loading 和 scroll 或 resize 和 Intersection Observer 方式支持延迟加载 延迟加载可以减少启动期间的总体流量消耗和网络争用，减少图像解码所需的时间来减少主线程上的处理。 避免延迟加载可视区域内的，以免对 lcp 产生负面影响 ","permalink":"https://dummyEkko.github.io/posts/tech/lazyload/","summary":"懒加载 懒加载也叫延迟加载，延迟加载这一解决方案可以减少初始网页载荷和加载时间。 我们通常会延迟加载 非关键资源，在需要的时候再加载这些非关键资源。就图片来说，“非关键”通常指的是“屏幕外”。 为何要延迟加载图片或视频？ 减少初始网页加载时间、初始页面重量以及系统资源用量。 用户可能永远不查","title":"Lazyload"},{"content":"静态提升 静态节点提升 编译器将模板编译成render函数的时候，会发现静态节点，然后进行静态提升。\n静态提升是以树为单位\n例如：\n\u0026lt;div\u0026gt; \u0026lt;div\u0026gt;foo\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{{ bar }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 对应的渲染函数：\n// before function render() { return ( openBlock(), createBlock(\u0026#39;div\u0026#39;, null, [ createVNode(\u0026#39;p\u0026#39;, null, \u0026#39;foo\u0026#39;), createVNode(\u0026#39;p\u0026#39;, null, ctx.bar, 1 /*TEXT*/), ]) ) } // after // 将纯静态的 虚拟节点提升 const hosit1 = createVNode(\u0026#39;p\u0026#39;, null, \u0026#39;foo\u0026#39;) function render() { return ( openBlock(), createBlock(\u0026#39;div\u0026#39;, null, [ hosit1, // 传递引用，这样每次render时候不会重新生成 createVNode(\u0026#39;p\u0026#39;, null, ctx.bar, 1 /*TEXT*/), ]) ) } 静态属性提升 例如：\n\u0026lt;div\u0026gt; \u0026lt;div foo=\u0026#34;bar\u0026#34; a=b\u0026gt;{{ text }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 可以将静态属性提升\nconst hositProps = { foo: \u0026#39;bar\u0026#39;, a: \u0026#39;b\u0026#39; } function render() { return ( openBlock(), createBlock(\u0026#39;div\u0026#39;, null, [ createVNode(\u0026#39;div\u0026#39;, hositProps, ctx.text, 1 /*TEXT*/), ]) ) } 预字符串化 例如：\n\u0026lt;div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!-- ... 20个p标签 --\u0026gt; \u0026lt;/div\u0026gt; 我们将静态节点序列化为字符串，并生成一个 static 类型的 vnode:\nconst hoistStatic = createStaticVNode(\u0026#39;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;...20个...\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026#39;) render() { return (openBlock(), createBlock(\u0026#39;div\u0026#39;, null, [hoistStatic])) } 优势在于：\n大块的静态内容可以通过 innerHTML 进行设置，性能上有一定优势 减少内容占用 减少虚拟节点 虚拟节点创建产生的性能开销 缓存内联事件处理函数 例如：\n\u0026lt;Comp @change=\u0026#34;a + b\u0026#34;/\u0026gt; 编译器会将其编译为：\nfunction render() { return h(Comp, { onChange: () =\u0026gt; (ctx.a + ctx.b) // 每次重新渲染，都会为组件创建一个全新的 props对象。同时props中的onChange属性值也会是一个 // 全新的值 }) } // 我们增加缓存进行优化 function render() { return h(Comp, { onChange: cache[0] || (cache[0] = ($event) =\u0026gt; (ctx.a + ctx.b)) // 全新的值 }) } PatchFlag \u0026amp; block 靶向更新和block树\n例如模板：\n\u0026lt;div\u0026gt; \u0026lt;div\u0026gt;foo\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{{ bar }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 编译成传统的虚拟dom：\nconst vnode = { tag: \u0026#39;div\u0026#39;, children: [ { tag: \u0026#39;p\u0026#39;, children: \u0026#39;foo\u0026#39;}, { tag: \u0026#39;p\u0026#39;, children: ctx.bar }, ] } 编译优化后，编译器会将提取到他的关键信息附着在vnode上：\n// 只要存在 `patchFlag` 我们称为动态节点。 const PatchFlags = { TEXT: 1, // 表示动态文本内容 CLASS: 2, // 表示动态的 class STYLE: 3, // 表示动态的 style PROPS: 4 // 表示动态的 props // 省略... } const vnode = { tag: \u0026#39;div\u0026#39;, children: [ { tag: \u0026#39;p\u0026#39;, children: \u0026#39;foo\u0026#39;}, { tag: \u0026#39;p\u0026#39;, children: ctx.bar, patchFlag: PatchFlags.TEXT }, // 这是一个动态节点 ] } 有了这项信息，我们可以将动态子节点提出来，存储到该虚拟节点的 dynamicChildren:\nconst vnode = { tag: \u0026#39;div\u0026#39;, children: [ { tag: \u0026#39;p\u0026#39;, children: \u0026#39;foo\u0026#39;}, { tag: \u0026#39;p\u0026#39;, children: ctx.bar, patchFlag: PatchFlags.TEXT }, // 这是一个动态节点 ], // children 中的动态节点被提取到这里 dynamicChildren: [ { tag: \u0026#39;p\u0026#39;, children: ctx.bar, patchFlag: PatchFlags.TEXT }, // 这是一个动态节点 ] } 我们将带有 dynamicChildren 的虚拟节点称为 block（块）\n有了 block 概念后，渲染器更新操作将会以 block 为维度，也就是说，当渲染器在更新一个 block 时，会忽略虚拟节点的 children，而是 直接找到 dynamicChildren 数组，并且只更新数组中的动态节点，从而跳过静态内容，只更新动态内容。同时，由于动态节点中存在补丁标志(PatchFlags), 所以只需要靶向更新。\n什么节点会称为 block 节点？\n所有模板的根节点 带有 v-if、v-for、v-else-if ","permalink":"https://dummyEkko.github.io/posts/tech/vue3%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/","summary":"静态提升 静态节点提升 编译器将模板编译成render函数的时候，会发现静态节点，然后进行静态提升。 静态提升是以树为单位 例如： \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;foo\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{{ bar }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 对应的渲染函数： // before function render() { return ( openBlock(), createBlock(\u0026#39;div\u0026#39;, null, [ createVNode(\u0026#39;p\u0026#39;, null, \u0026#39;foo\u0026#39;), createVNode(\u0026#39;p\u0026#39;, null, ctx.bar, 1 /*TEXT*/), ]) ) } // after // 将纯静态的 虚拟节点提升 const hosit1 = createVNode(\u0026#39;p\u0026#39;, null, \u0026#39;foo\u0026#39;) function render() { return ( openBlock(), createBlock(\u0026#39;div\u0026#39;, null, [ hosit1, // 传递引用，这样每次ren","title":"Vue3编译优化"},{"content":"字体加载 @font-face @font-face 用来申明网络字体，它至少要声明将用于引用字体的名称，并指明相应字体文件的位置。\n@font-face { font-family: \u0026#34;Open Sans\u0026#34;; src: url(\u0026#34;/fonts/OpenSans-Regular-webfont.woff2\u0026#34;) format(\u0026#34;woff2\u0026#34;); } h1 { /* 这个时候才会去下载 font-face 声明的字体 */ font-family: \u0026#34;Open Sans\u0026#34; } @font-face 声明本身不会触发字体下载, 只有通过在网页上使用的样式引用某个字体时，系统才会下载该字体\nunicode-range 使用介绍：\ntodo\n字体渲染 当面临尚未加载的网络字体时，浏览器将面临一个困境：是否应该在网络字体到达之前暂停渲染文本？还是应该在网页字体到达之前以后备字体呈现文本？\n默认情况下，如果关联的网页字体尚未加载，基于 Chromium 和 Firefox 的浏览器将会阻止文本呈现，最长可持续3秒钟; Safari 将无限期地阻止文本呈现。\n概括就是文本不可见在字体还没加载前\n可以使用 font-display 属性来配置此行为。\nfont-display font-display 属性决定了一个 @font-face 在不同的下载时间和可用时间下是如何展示的.\nfont-display 可选值：\n值 屏蔽期 交换期 auto 因浏览器而异 因浏览器而异 block 2-3 秒 无限 swap 0 毫秒 无限 fallback 100 毫秒 3 秒 optional 100 毫秒 无 屏蔽期：屏蔽期从浏览器请求网页字体时开始计算。在屏蔽期间，如果网页字体不可用，相应字体将以不可见的后备字体呈现，因此用户将看不到相应文本。如果在屏蔽期结束后该字体不可用，它将以后备字体呈现。 交换期：交换期在屏蔽期之后。如果网页字体在交换期内可用，则会被“交换”。 如何设置合理的 font-display 如果性能是我们的头等大事 那么使用 font-display: optional。\n优点: 文本渲染的延迟不超过 100 毫秒, 并且能够保证不会发生与字体交换相关的布局偏移(优化CLS)\n缺点: 如果网页字体延迟显示，将无法使用网页字体。\n快速显示文本是首要任务，仍想确保使用网页字体 使用 font-display: swap\n优点: 先会以默认字体展示，等网页字体加载完成后，进行交换。\n缺点：会导致布局偏移。\n总结: 尽早加载字体，例如 link preload 进行预加载。\n确保文本以网页字体显示是首要任务 使用 font-display: block。\n缺点：字体没加载完文本将不可见。\n总结: 尽早加载字体，例如 link preload 进行预加载。\n对字体优化总结 字体加载时机 通过上面文章可以知道 只有读到网络字体被使用时，才会触发@font-face下载逻辑。\n优化方案：\n关键字体通过 preload 进行加载。 前提条件：如果明确字体的情况下。 注意点：字体文件必须通过 CORS 连接，预加载情况下，preload 会忽略 unicode-range 声明，如果使用得当，应仅用于加载一种字体格式。 预先连接到关键的第三方源 link rel=\u0026quot;preconnect\u0026quot; 前提条件：可能多个字体，不明确哪个是关键， 注意点：字体文件必须通过 CORS 连接 字体加载速度 字体加载速度主要是网络优化，一个是字体大小一个是合理的网络传输\n采用 CDN 托管字体和 HTTP/2。 使用 WOFF2 （广泛的浏览器支持，并提供最佳的压缩效果， WOFF2 使用 Brotli，因此其压缩效果比 WOFF 高 30%） 子集 通过使用 unicode-range 会告知浏览器某种字体可用于哪些字符, 将一个大的字体分成几个子集，需要时加载子集从而减小体积 补充 为什么 字体的预加载需要通过 CORS 连接？ todo\n","permalink":"https://dummyEkko.github.io/posts/tech/%E5%AD%97%E4%BD%93%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","summary":"字体加载 @font-face @font-face 用来申明网络字体，它至少要声明将用于引用字体的名称，并指明相应字体文件的位置。 @font-face { font-family: \u0026#34;Open Sans\u0026#34;; src: url(\u0026#34;/fonts/OpenSans-Regular-webfont.woff2\u0026#34;) format(\u0026#34;woff2\u0026#34;); } h1 { /* 这个时候才会去下载 font-face 声明的字体 */ font-family: \u0026#34;Open Sans\u0026#34; } @font-face 声明本身不会触发字体下载, 只有通过在网页上使用的样式引用某个字体时，系统才会下载该字体 unicode-range 使用介绍： todo 字体渲染 当面临尚未加载的","title":"字体最佳实践"},{"content":" Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群 787018782\n","permalink":"https://dummyEkko.github.io/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内 👉Hugo博客交流群 787018782","title":"🤝友链"},{"content":"","permalink":"https://dummyEkko.github.io/about/","summary":"","title":"🙋🏻‍♂️关于"}]
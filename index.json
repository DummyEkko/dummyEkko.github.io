[{"content":"渲染流程 参考文章\n渲染进程 渲染程序进程负责标签页内发生的一切。 合成器和光栅线程也会在渲染程序进程内运行，以便高效、流畅地渲染页面。 渲染程序进程的核心任务是将 HTML、CSS 和 JavaScript 转换为用户可与之互动的网页。\n渲染进程中的主线程会处理大多数工作，例如：\n解析文本字符串 (HTML)，生成 DOM。 计算样式 布局 处理图层 每秒把⻚⾯画 60 次 执⾏全局 JS 代码 执⾏事件处理函数 执⾏计时器的回调函数 Web Worker 或 Service Worker，则部分 JavaScript 将由工作器线程处理。\n渲染流程 DOM构建 为什么需要构建 DOM 树？ 因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。\n预加载资源 网站通常使用图片、CSS 和 JavaScript 等外部资源。\n加快速度，系统会并发运行**“预加载扫描程序”**。如果 HTML 文档中包含 \u0026lt;img\u0026gt; 或 \u0026lt;link\u0026gt; 等内容，预加载扫描器会查看由 HTML 解析器生成的 token，并将请求发送到浏览器进程中的网络线程。\njs是如何阻止dom树构建 当HTML解析器找到 \u0026lt;script\u0026gt; 标记时，它会暂停解析 HTML 文档，并加载、解析并执行 JavaScript 代码。因为 js 可能会修改当前已经生成的dom结构。\n不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行。\n样式计算（Recalculate Style） 样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成:\n把 CSS 转换为浏览器能够理解的结构——styleSheets。 转换样式表中的属性值，使其标准化(主要是将指标准化)。 计算出 DOM 树中每个节点的具体样式(遵守 CSS 的继承和层叠两个规则) 布局 布局是查找元素几何形状的过程。主线程会遍历 DOM 和计算出的样式，并创建包含 x y 坐标和边界框大小等信息的布局树。\n布局树的结构可能与 DOM 树类似，但它仅包含与页面上可见内容相关的信息。 display: none，则该元素不属于布局树的一部分（但是，具有 visibility: hidden 的元素位于布局树中）。\n分层 渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）\n那么需要满足什么条件，渲染引擎才会为特定的节点创建新的图层呢？\n拥有层叠上下文属性的元素会被提升为单独的一层（position, z-index, filter: blur(5px), opacity 需要剪裁（clip）的地方也会被创建为图层 主线程会将该信息提交到合成器线程。\n图层绘制 合成器线程会把一个图层的绘制拆分成很多图块，并将每个图块发送到光栅线程。\n光栅化 光栅线程会光栅化每个图块并将其存储在 GPU 内存中。\n合成和显示 将图块进行光栅化后，合成器线程会收集称为“绘制四边形”的图块信息，以创建合成器帧。然后通过 IPC 将合成器帧提交到浏览器进程。\n合成的优势在于，它在完成时不涉及主线程。合成器线程不需要等待样式计算或 JavaScript 执行。因此，仅合成动画被认为是实现流畅性能的最佳方式。如果需要再次计算布局或绘制，则必须涉及主线程。\n总结 渲染进程将 HTML 生成 DOM树结构 将 CSS 样式表 转换成 styleSheets 创建布局树，并且计算布局信息（位置，是否显示）。 分层，生成图层树，提交给合成线程。 合成线程将图层分为多个图块，发给光栅线程。 光栅线程光栅化每个图块并存于GPU中 合成线程创建合成器帧 通过IPC提交给浏览器进程，界面更改，这些合成器帧会发送到 GPU 以在屏幕上显示。 ","permalink":"https://dummyEkko.github.io/posts/tech/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/","summary":"渲染流程 参考文章 渲染进程 渲染程序进程负责标签页内发生的一切。 合成器和光栅线程也会在渲染程序进程内运行，以便高效、流畅地渲染页面。 渲染程序进程的核心任务是将 HTML、CSS 和 JavaScript 转换为用户可与之互动的网页。 渲染进程中的主线程会处理大多数工作，例如： 解析文本字符串 (HTML)，生成 DO","title":"渲染流程"},{"content":"懒加载 懒加载也叫延迟加载，延迟加载这一解决方案可以减少初始网页载荷和加载时间。\n我们通常会延迟加载 非关键资源，在需要的时候再加载这些非关键资源。就图片来说，“非关键”通常指的是“屏幕外”。\n为何要延迟加载图片或视频？ 减少初始网页加载时间、初始页面重量以及系统资源用量。 用户可能永远不查看该内容，这样避免浪费流量，费处理时间、电量和其他资源（下载媒体资源后，浏览器必须对其进行解码，并在视口中呈现其内容）。 效果如：\n延迟加载图片 loading 属性 Chrome 和 Firefox 都支持通过 loading 属性进行延迟加载。\n可选值：\neager: 立即加载图像，不管它是否在可视视口（visible viewport）之外（默认值） lazy: 延迟加载图像，直到它和视口接近到一个计算得到的距离（由浏览器定义）。目的是在需要图像之前，避免加载图像所需要的网络和存储带宽。 如果浏览器不支持延迟加载，系统会忽略该属性，并照常立即加载图片。\n判断是否支持 loading\nif (\u0026#39;loading\u0026#39; in HTMLImageElement.prototype) { // supported in browser } else { // fetch polyfill/third-party library } scroll 或 resize \u0026lt;body\u0026gt; \u0026lt;img loading=\u0026#34;lazy\u0026#34; class=\u0026#39;img-item\u0026#39; src=\u0026#34;https://img.zcool.cn/community/011e0e5c231dcaa80121df9063b03f.jpg@1280w_1l_2o_100sh.jpg\u0026#34; data-original=\u0026#34;https://img.zcool.cn/community/011e0e5c231dcaa80121df9063b03f.jpg@1280w_1l_2o_100sh.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;img loading=\u0026#34;lazy\u0026#34; class=\u0026#39;img-item\u0026#39; src=\u0026#34;\u0026#34; data-original=\u0026#34;https://img.zcool.cn/community/01427a5c63c7dba801213f26fa8f1f.jpg@1280w_1l_2o_100sh.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;img loading=\u0026#34;lazy\u0026#34; class=\u0026#39;img-item\u0026#39; src=\u0026#34;\u0026#34; data-original=\u0026#34;https://img.zcool.cn/community/0132fb60a7171011013f472074ee82.jpg@1280w_1l_2o_100sh.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;img loading=\u0026#34;lazy\u0026#34; class=\u0026#39;img-item\u0026#39; src=\u0026#34;\u0026#34; data-original=\u0026#34;https://pic2.zhimg.com/v2-ac79ec66a08cdbbfd36c3f9e4f307077_1440w.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;img loading=\u0026#34;lazy\u0026#34; class=\u0026#39;img-item\u0026#39; src=\u0026#34;\u0026#34; data-original=\u0026#34;https://img.zcool.cn/community/01702360a7171511013e3b7d2249ef.jpg@1280w_1l_2o_100sh.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;img loading=\u0026#34;lazy\u0026#34; class=\u0026#39;img-item\u0026#39; src=\u0026#34;\u0026#34; data-original=\u0026#34;https://img.zcool.cn/community/01c9e05da91bcea8012163bae9a7ea.jpg@2o.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;img loading=\u0026#34;lazy\u0026#34; class=\u0026#39;img-item\u0026#39; src=\u0026#34;\u0026#34; data-original=\u0026#34;https://img.zcool.cn/community/010c155dcec2b0a8012053c0802a12.jpg@3000w_1l_0o_100sh.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;img loading=\u0026#34;lazy\u0026#34; class=\u0026#39;img-item\u0026#39; src=\u0026#34;\u0026#34; data-original=\u0026#34;https://pic2.zhimg.com/v2-b2ab50d677e6f8a9101dae446dd99acd_r.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;img loading=\u0026#34;lazy\u0026#34; class=\u0026#39;img-item\u0026#39; src=\u0026#34;\u0026#34; data-original=\u0026#34;https://img.3dmgame.com/uploads/images/thumbpicfirst/20180824/1535099402_352803.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;img loading=\u0026#34;lazy\u0026#34; class=\u0026#39;img-item\u0026#39; src=\u0026#34;\u0026#34; data-original=\u0026#34;https://img.zcool.cn/community/0193a55b9df41ba8012099c8aedcd0.jpg@3000w_1l_0o_100sh.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;script\u0026gt; // 拿到可视觉区域的高度 let viewHeight = document.documentElement.clientHeight; function lazyLoad(){ // 拿到所有的img元素 let imgs = document.querySelectorAll(\u0026#39;img[data-original]\u0026#39;); imgs.forEach(el=\u0026gt;{ // getBoundingClientRect()专门获取容器的几何信息 let rect = el.getBoundingClientRect() if(rect.top \u0026lt; viewHeight){ // img元素自带一个构造函数，可以创建一个图片对象 let image = new Image() // js专有写法dataset.original; = data-original image.src = el.dataset.original; image.onload = function(){ el.src = image.src } // 图片加载完毕就移除属性 el.removeAttribute(\u0026#39;data-original\u0026#39;) } }) } lazyLoad() // 添加滚动事件监听器 document.addEventListener(\u0026#39;scroll\u0026#39;,lazyLoad) \u0026lt;/script\u0026gt; Intersection Observer 性能更佳且更高效\n\u0026lt;script\u0026gt; document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() { var lazyImages = [].slice.call(document.querySelectorAll(\u0026#34;img.img-item\u0026#34;)); if (\u0026#34;IntersectionObserver\u0026#34; in window) { let lazyImageObserver = new IntersectionObserver(function(entries, observer) { entries.forEach(function(entry) { if (entry.isIntersecting) { let lazyImage = entry.target; lazyImage.src = lazyImage.dataset.original; // lazyImage.srcset = lazyImage.dataset.srcset; // lazyImage.classList.remove(\u0026#34;lazy\u0026#34;); lazyImageObserver.unobserve(lazyImage); } }); }); lazyImages.forEach(function(lazyImage) { lazyImageObserver.observe(lazyImage); }); } else { } \u0026lt;/script\u0026gt; 总结 可以通过 loading 和 scroll 或 resize 和 Intersection Observer 方式支持延迟加载 延迟加载可以减少启动期间的总体流量消耗和网络争用，减少图像解码所需的时间来减少主线程上的处理。 避免延迟加载可视区域内的，以免对 lcp 产生负面影响 ","permalink":"https://dummyEkko.github.io/posts/tech/lazyload/","summary":"懒加载 懒加载也叫延迟加载，延迟加载这一解决方案可以减少初始网页载荷和加载时间。 我们通常会延迟加载 非关键资源，在需要的时候再加载这些非关键资源。就图片来说，“非关键”通常指的是“屏幕外”。 为何要延迟加载图片或视频？ 减少初始网页加载时间、初始页面重量以及系统资源用量。 用户可能永远不查","title":"Lazyload"},{"content":"XSS Cross-Site Scripting 跨站脚本攻击，攻击者将恶意代码注入到受害者所访问的网站中。这些恶意代码通常是JavaScript脚本，但也可以包括HTML和其他类型的代码。\n⚠️XSS危害 如果页面被注入了恶意JavaScript脚本，恶意脚本都能做哪些事情：\n可以窃取Cookie信息: 恶意JavaScript可以通过document.cookie获取Cookie信息，然后通过XMLHttpRequest或者Fetch加上CORS功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。 可以通过修改 DOM 伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。 还可以在页面内生成浮窗广告，这些广告会严重地影响用户体验。 可以监听用户行为: 恶意 JavaScript 可以使用addEventListener接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。 🔐防范措施 对输入脚本进行过滤或转码：例如v-html插入的文本。 充分利用 CSP（Content Security Policy） 渲染引擎还有一个安全检查模块叫 XSSAuditor，是用来检测词法安全的。在分词器解析出来Token之后，它会检测这些模块是否安全，比如是否引用了外部脚本，是否符合 CSP 规范，是否存在跨站点请求等。如果出现不符合规范的内容,XSSAuditor会对该脚本或者下载任务进行拦截。\nCSP 有如下几个功能：\n限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的； 禁止向第三方域提交数据 禁止执行内联脚本和未授权的脚本。 使用 HttpOnly 属性 CSRF 跨站请求伪造（Cross-Site Request Forgery，简称 CSRF） 攻击者通过诱使受害者访问恶意网站或点击恶意链接，从而在受害者的浏览器上执行未经授权的操作。由于受害者的浏览器会自动携带已登录网站的 Cookie，因此攻击者可以利用这一特性伪造受害者的身份执行操作，如转账、修改密码或其他敏感操作。\nCSRF 攻击有以下特点：\n攻击者无法直接获取受害者的数据，但可以伪造受害者执行操作。 攻击者需要诱使受害者访问恶意网站或点击恶意链接。 攻击者通常会利用受害者已登录的状态来进行攻击。 🔐防范措施 使用 SameSite Cookie 属性：将 Cookie 的 SameSite 属性设置为 \u0026quot;strict\u0026quot; 或 \u0026quot;lax\u0026quot; 可以限制浏览器在跨站请求时发送 Cookie。这样，即使攻击者诱导受害者访问恶意网站，由于Cookie不会被发送，攻击者也无法伪造受害者的身份执行操作。 验证请求来源：对于敏感操作，可以检查 HTTP 请求头中的 Referer 或 Origin 属性，确保请求来自于可信的来源。这可以防止来自恶意网站的跨站请求。 使用 CSRF 令牌：为每个表单或敏感操作生成一个随机令牌（Token），并将该令牌与用户的会话绑定。当用户提交表单或执行操作时，需要验证令牌是否有效和匹配。这样攻击者就无法伪造有效的令牌，从而降低CSRF攻击的风险。 使用双重认证：对于重要操作（如转账、修改密码等），可以使用双重认证（如短信验证码、邮箱验证码等）来验证用户的身份。 CSP(Content Security Policy) CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。\n两种开启CSP方法: HTTP 响应头的Content-Security-Policy的字段 HTTP 响应头 Content-Security-Policy 允许站点管理者控制用户代理能够为指定的页面加载哪些资源。除了少数例外情况，设置的政策主要涉及指定服务器的源和脚本结束点。\n例如：\nContent-Security-Policy: script-src \u0026#39;self\u0026#39;; object-src \u0026#39;none\u0026#39;; style-src cdn.example.org third-party.org; child-src https: 字段:\nchild-src: 为 Web Workers 和其他内嵌浏览器内容（例如用 和 加载到页面的内容）定义合法的源地址。 connect-src: 限制能通过脚本接口加载的 URL。 default-src: 其他取指令提供备用服务 fetch directives。 font-src: 设置允许通过 @font-face 加载的字体源地址。 frame-src：设置允许通过类似 和 标签加载的内嵌内容的源地址。 img-src：限制图片和图标的源地址 manifest-src：限制应用声明文件的源地址。 media-src：限制通过 、 或 标签加载的媒体文件的源地址。 object-src：限制 或 标签的源地址。 prefetch-src: 指定预加载或预渲染的允许源地址。 script-src: 限制 JavaScript 的源地址。 style-src: 限制层叠样式表文件源。 mdn\n通过网页的\u0026lt;meta\u0026gt;标签 \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;script-src \u0026#39;self\u0026#39;; object-src \u0026#39;none\u0026#39;; style-src cdn.example.org third-party.org; child-src https:\u0026#34;\u0026gt; ","permalink":"https://dummyEkko.github.io/posts/tech/xss%E5%92%8Ccrsf/","summary":"XSS Cross-Site Scripting 跨站脚本攻击，攻击者将恶意代码注入到受害者所访问的网站中。这些恶意代码通常是JavaScript脚本，但也可以包括HTML和其他类型的代码。 ⚠️XSS危害 如果页面被注入了恶意JavaScript脚本，恶意脚本都能做哪些事情： 可以窃取Cookie信息: 恶意JavaScript","title":"WEB网络安全"},{"content":"静态提升 静态节点提升 编译器将模板编译成render函数的时候，会发现静态节点，然后进行静态提升。\n静态提升是以树为单位\n例如：\n\u0026lt;div\u0026gt; \u0026lt;div\u0026gt;foo\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{{ bar }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 对应的渲染函数：\n// before function render() { return ( openBlock(), createBlock(\u0026#39;div\u0026#39;, null, [ createVNode(\u0026#39;p\u0026#39;, null, \u0026#39;foo\u0026#39;), createVNode(\u0026#39;p\u0026#39;, null, ctx.bar, 1 /*TEXT*/), ]) ) } // after // 将纯静态的 虚拟节点提升 const hosit1 = createVNode(\u0026#39;p\u0026#39;, null, \u0026#39;foo\u0026#39;) function render() { return ( openBlock(), createBlock(\u0026#39;div\u0026#39;, null, [ hosit1, // 传递引用，这样每次render时候不会重新生成 createVNode(\u0026#39;p\u0026#39;, null, ctx.bar, 1 /*TEXT*/), ]) ) } 静态属性提升 例如：\n\u0026lt;div\u0026gt; \u0026lt;div foo=\u0026#34;bar\u0026#34; a=b\u0026gt;{{ text }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 可以将静态属性提升\nconst hositProps = { foo: \u0026#39;bar\u0026#39;, a: \u0026#39;b\u0026#39; } function render() { return ( openBlock(), createBlock(\u0026#39;div\u0026#39;, null, [ createVNode(\u0026#39;div\u0026#39;, hositProps, ctx.text, 1 /*TEXT*/), ]) ) } 预字符串化 例如：\n\u0026lt;div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!-- ... 20个p标签 --\u0026gt; \u0026lt;/div\u0026gt; 我们将静态节点序列化为字符串，并生成一个 static 类型的 vnode:\nconst hoistStatic = createStaticVNode(\u0026#39;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;...20个...\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026#39;) render() { return (openBlock(), createBlock(\u0026#39;div\u0026#39;, null, [hoistStatic])) } 优势在于：\n大块的静态内容可以通过 innerHTML 进行设置，性能上有一定优势 减少内容占用 减少虚拟节点 虚拟节点创建产生的性能开销 缓存内联事件处理函数 例如：\n\u0026lt;Comp @change=\u0026#34;a + b\u0026#34;/\u0026gt; 编译器会将其编译为：\nfunction render() { return h(Comp, { onChange: () =\u0026gt; (ctx.a + ctx.b) // 每次重新渲染，都会为组件创建一个全新的 props对象。同时props中的onChange属性值也会是一个 // 全新的值 }) } // 我们增加缓存进行优化 function render() { return h(Comp, { onChange: cache[0] || (cache[0] = ($event) =\u0026gt; (ctx.a + ctx.b)) // 全新的值 }) } PatchFlag \u0026amp; block 靶向更新和block树\n例如模板：\n\u0026lt;div\u0026gt; \u0026lt;div\u0026gt;foo\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{{ bar }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 编译成传统的虚拟dom：\nconst vnode = { tag: \u0026#39;div\u0026#39;, children: [ { tag: \u0026#39;p\u0026#39;, children: \u0026#39;foo\u0026#39;}, { tag: \u0026#39;p\u0026#39;, children: ctx.bar }, ] } 编译优化后，编译器会将提取到他的关键信息附着在vnode上：\n// 只要存在 `patchFlag` 我们称为动态节点。 const PatchFlags = { TEXT: 1, // 表示动态文本内容 CLASS: 2, // 表示动态的 class STYLE: 3, // 表示动态的 style PROPS: 4 // 表示动态的 props // 省略... } const vnode = { tag: \u0026#39;div\u0026#39;, children: [ { tag: \u0026#39;p\u0026#39;, children: \u0026#39;foo\u0026#39;}, { tag: \u0026#39;p\u0026#39;, children: ctx.bar, patchFlag: PatchFlags.TEXT }, // 这是一个动态节点 ] } 有了这项信息，我们可以将动态子节点提出来，存储到该虚拟节点的 dynamicChildren:\nconst vnode = { tag: \u0026#39;div\u0026#39;, children: [ { tag: \u0026#39;p\u0026#39;, children: \u0026#39;foo\u0026#39;}, { tag: \u0026#39;p\u0026#39;, children: ctx.bar, patchFlag: PatchFlags.TEXT }, // 这是一个动态节点 ], // children 中的动态节点被提取到这里 dynamicChildren: [ { tag: \u0026#39;p\u0026#39;, children: ctx.bar, patchFlag: PatchFlags.TEXT }, // 这是一个动态节点 ] } 我们将带有 dynamicChildren 的虚拟节点称为 block（块）\n有了 block 概念后，渲染器更新操作将会以 block 为维度，也就是说，当渲染器在更新一个 block 时，会忽略虚拟节点的 children，而是 直接找到 dynamicChildren 数组，并且只更新数组中的动态节点，从而跳过静态内容，只更新动态内容。同时，由于动态节点中存在补丁标志(PatchFlags), 所以只需要靶向更新。\n什么节点会称为 block 节点？\n所有模板的根节点 带有 v-if、v-for、v-else-if ","permalink":"https://dummyEkko.github.io/posts/tech/vue3%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/","summary":"静态提升 静态节点提升 编译器将模板编译成render函数的时候，会发现静态节点，然后进行静态提升。 静态提升是以树为单位 例如： \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;foo\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{{ bar }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 对应的渲染函数： // before function render() { return ( openBlock(), createBlock(\u0026#39;div\u0026#39;, null, [ createVNode(\u0026#39;p\u0026#39;, null, \u0026#39;foo\u0026#39;), createVNode(\u0026#39;p\u0026#39;, null, ctx.bar, 1 /*TEXT*/), ]) ) } // after // 将纯静态的 虚拟节点提升 const hosit1 = createVNode(\u0026#39;p\u0026#39;, null, \u0026#39;foo\u0026#39;) function render() { return ( openBlock(), createBlock(\u0026#39;div\u0026#39;, null, [ hosit1, // 传递引用，这样每次ren","title":"Vue3编译优化"},{"content":"字体加载 @font-face @font-face 用来申明网络字体，它至少要声明将用于引用字体的名称，并指明相应字体文件的位置。\n@font-face { font-family: \u0026#34;Open Sans\u0026#34;; src: url(\u0026#34;/fonts/OpenSans-Regular-webfont.woff2\u0026#34;) format(\u0026#34;woff2\u0026#34;); } h1 { /* 这个时候才会去下载 font-face 声明的字体 */ font-family: \u0026#34;Open Sans\u0026#34; } @font-face 声明本身不会触发字体下载, 只有通过在网页上使用的样式引用某个字体时，系统才会下载该字体\nunicode-range 使用介绍：\ntodo\n字体渲染 当面临尚未加载的网络字体时，浏览器将面临一个困境：是否应该在网络字体到达之前暂停渲染文本？还是应该在网页字体到达之前以后备字体呈现文本？\n默认情况下，如果关联的网页字体尚未加载，基于 Chromium 和 Firefox 的浏览器将会阻止文本呈现，最长可持续3秒钟; Safari 将无限期地阻止文本呈现。\n概括就是文本不可见在字体还没加载前\n可以使用 font-display 属性来配置此行为。\nfont-display font-display 属性决定了一个 @font-face 在不同的下载时间和可用时间下是如何展示的.\nfont-display 可选值：\n值 屏蔽期 交换期 auto 因浏览器而异 因浏览器而异 block 2-3 秒 无限 swap 0 毫秒 无限 fallback 100 毫秒 3 秒 optional 100 毫秒 无 屏蔽期：屏蔽期从浏览器请求网页字体时开始计算。在屏蔽期间，如果网页字体不可用，相应字体将以不可见的后备字体呈现，因此用户将看不到相应文本。如果在屏蔽期结束后该字体不可用，它将以后备字体呈现。 交换期：交换期在屏蔽期之后。如果网页字体在交换期内可用，则会被“交换”。 如何设置合理的 font-display 如果性能是我们的头等大事 那么使用 font-display: optional。\n优点: 文本渲染的延迟不超过 100 毫秒, 并且能够保证不会发生与字体交换相关的布局偏移(优化CLS)\n缺点: 如果网页字体延迟显示，将无法使用网页字体。\n快速显示文本是首要任务，仍想确保使用网页字体 使用 font-display: swap\n优点: 先会以默认字体展示，等网页字体加载完成后，进行交换。\n缺点：会导致布局偏移。\n总结: 尽早加载字体，例如 link preload 进行预加载。\n确保文本以网页字体显示是首要任务 使用 font-display: block。\n缺点：字体没加载完文本将不可见。\n总结: 尽早加载字体，例如 link preload 进行预加载。\n对字体优化总结 字体加载时机 通过上面文章可以知道 只有读到网络字体被使用时，才会触发@font-face下载逻辑。\n优化方案：\n关键字体通过 preload 进行加载。 前提条件：如果明确字体的情况下。 注意点：字体文件必须通过 CORS 连接，预加载情况下，preload 会忽略 unicode-range 声明，如果使用得当，应仅用于加载一种字体格式。 预先连接到关键的第三方源 link rel=\u0026quot;preconnect\u0026quot; 前提条件：可能多个字体，不明确哪个是关键， 注意点：字体文件必须通过 CORS 连接 字体加载速度 字体加载速度主要是网络优化，一个是字体大小一个是合理的网络传输\n采用 CDN 托管字体和 HTTP/2。 使用 WOFF2 （广泛的浏览器支持，并提供最佳的压缩效果， WOFF2 使用 Brotli，因此其压缩效果比 WOFF 高 30%） 子集 通过使用 unicode-range 会告知浏览器某种字体可用于哪些字符, 将一个大的字体分成几个子集，需要时加载子集从而减小体积 补充 为什么 字体的预加载需要通过 CORS 连接？ todo\n","permalink":"https://dummyEkko.github.io/posts/tech/%E5%AD%97%E4%BD%93%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","summary":"字体加载 @font-face @font-face 用来申明网络字体，它至少要声明将用于引用字体的名称，并指明相应字体文件的位置。 @font-face { font-family: \u0026#34;Open Sans\u0026#34;; src: url(\u0026#34;/fonts/OpenSans-Regular-webfont.woff2\u0026#34;) format(\u0026#34;woff2\u0026#34;); } h1 { /* 这个时候才会去下载 font-face 声明的字体 */ font-family: \u0026#34;Open Sans\u0026#34; } @font-face 声明本身不会触发字体下载, 只有通过在网页上使用的样式引用某个字体时，系统才会下载该字体 unicode-range 使用介绍： todo 字体渲染 当面临尚未加载的","title":"字体最佳实践"},{"content":" Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群 787018782\n","permalink":"https://dummyEkko.github.io/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内 👉Hugo博客交流群 787018782","title":"🤝友链"},{"content":"","permalink":"https://dummyEkko.github.io/about/","summary":"","title":"🙋🏻‍♂️关于"}]